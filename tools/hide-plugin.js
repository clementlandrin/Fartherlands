// Generated by Haxe 5.0.0-alpha.1+69f6e0dc7
var $hx_exports = typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this;
$hx_exports["hide"] = $hx_exports["hide"] || {};
var $global = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this;
var $hxClasses = $hxClasses || {},$estr = function() { return js.Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {};
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EnumValue = {};
EnumValue.match = function(this1,pattern) {
	return false;
};
Math.__name__ = "Math";
var UInt = {};
UInt.add = function(a,b) {
	return a + b;
};
UInt.div = function(a,b) {
	return UInt.toFloat(a) / UInt.toFloat(b);
};
UInt.mul = function(a,b) {
	return a * b;
};
UInt.sub = function(a,b) {
	return a - b;
};
UInt.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
UInt.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
UInt.lt = function(a,b) {
	return UInt.gt(b,a);
};
UInt.lte = function(a,b) {
	return UInt.gte(b,a);
};
UInt.and = function(a,b) {
	return a & b;
};
UInt.or = function(a,b) {
	return a | b;
};
UInt.xor = function(a,b) {
	return a ^ b;
};
UInt.shl = function(a,b) {
	return a << b;
};
UInt.shr = function(a,b) {
	return a >>> b;
};
UInt.ushr = function(a,b) {
	return a >>> b;
};
UInt.mod = function(a,b) {
	return UInt.toFloat(a) % UInt.toFloat(b) | 0;
};
UInt.addWithFloat = function(a,b) {
	return UInt.toFloat(a) + b;
};
UInt.mulWithFloat = function(a,b) {
	return UInt.toFloat(a) * b;
};
UInt.divFloat = function(a,b) {
	return UInt.toFloat(a) / b;
};
UInt.floatDiv = function(a,b) {
	return a / UInt.toFloat(b);
};
UInt.subFloat = function(a,b) {
	return UInt.toFloat(a) - b;
};
UInt.floatSub = function(a,b) {
	return a - UInt.toFloat(b);
};
UInt.gtFloat = function(a,b) {
	return UInt.toFloat(a) > b;
};
UInt.equalsInt = function(a,b) {
	return a == b;
};
UInt.notEqualsInt = function(a,b) {
	return a != b;
};
UInt.equalsFloat = function(a,b) {
	return UInt.toFloat(a) == b;
};
UInt.notEqualsFloat = function(a,b) {
	return UInt.toFloat(a) != b;
};
UInt.gteFloat = function(a,b) {
	return UInt.toFloat(a) >= b;
};
UInt.floatGt = function(a,b) {
	return a > UInt.toFloat(b);
};
UInt.floatGte = function(a,b) {
	return a >= UInt.toFloat(b);
};
UInt.ltFloat = function(a,b) {
	return UInt.toFloat(a) < b;
};
UInt.lteFloat = function(a,b) {
	return UInt.toFloat(a) <= b;
};
UInt.floatLt = function(a,b) {
	return a < UInt.toFloat(b);
};
UInt.floatLte = function(a,b) {
	return a <= UInt.toFloat(b);
};
UInt.modFloat = function(a,b) {
	return UInt.toFloat(a) % b;
};
UInt.floatMod = function(a,b) {
	return a % UInt.toFloat(b);
};
UInt.negBits = function(this1) {
	return ~this1;
};
UInt.prefixIncrement = function(this1) {
	return ++this1;
};
UInt.postfixIncrement = function(this1) {
	return this1++;
};
UInt.prefixDecrement = function(this1) {
	return --this1;
};
UInt.postfixDecrement = function(this1) {
	return this1--;
};
UInt.toString = function(this1,radix) {
	return Std.string(UInt.toFloat(this1));
};
UInt.toInt = function(this1) {
	return this1;
};
UInt.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
Math.__name__ = "Math";
var js = js || {};
if(!js.node) js.node = {};
js.node.ChildProcess = require("child_process");
js.node.Crypto = require("crypto");
js.node.DnsErrorCode = require("dns");
js.node.Dns = require("dns");
js.node.Fs = require("fs");
js.node.Module = require("module");
js.node.Net = require("net");
js.node.Path = require("path");
if(!js.node.events) js.node.events = {};
js.node.events.EventEmitter = require("events").EventEmitter;
js.node.Stream = require("stream");
js.node.Timers = require("timers");
js.node.Util = require("util");
js.node.Zlib = require("zlib");
if(!js.node.buffer) js.node.buffer = {};
js.node.buffer.Buffer = require("buffer").Buffer;
if(!js.node.buffer._Buffer) js.node.buffer._Buffer = {};
js.node.buffer._Buffer.BufferModule = require("buffer");
if(!js.node.console) js.node.console = {};
js.node.console.Console = require("console").Console;
if(!js.node.stream) js.node.stream = {};
js.node.stream.Readable = require("stream").Readable;
js.node.stream.Duplex = require("stream").Duplex;
js.node.stream.Transform = require("stream").Transform;
js.node.stream.Writable = require("stream").Writable;
if(!js.node.net) js.node.net = {};
js.node.net.Server = require("net").Server;
js.node.net.Socket = require("net").Socket;
if(!js.node.url) js.node.url = {};
js.node.url.URL = require("url").URL;
js.node.url.URLSearchParams = require("url").URLSearchParams;
if(!js.node.zlib) js.node.zlib = {};
js.node.zlib.Deflate = require("zlib").Deflate;
js.node.zlib.DeflateRaw = require("zlib").DeflateRaw;
js.node.zlib.Gunzip = require("zlib").Gunzip;
js.node.zlib.Gzip = require("zlib").Gzip;
js.node.zlib.Inflate = require("zlib").Inflate;
js.node.zlib.InflateRaw = require("zlib").InflateRaw;
js.node.zlib.Unzip = require("zlib").Unzip;
var prefab = prefab || {};
prefab.Temporal = function() {
	hxsl.Shader.call(this);
};
$hxClasses["prefab.Temporal"] = prefab.Temporal;
prefab.Temporal.__name__ = "prefab.Temporal";
prefab.Temporal._SHADER = null;
prefab.Temporal.__super__ = hxsl.Shader;
prefab.Temporal.prototype = $extend(hxsl.Shader.prototype,{
	PAST__: null
	,get_PAST: function() {
		return this.PAST__;
	}
	,set_PAST: function(_v) {
		this.constModified = true;
		return this.PAST__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.PAST__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.PAST__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.PAST__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(prefab.Temporal.prototype);
		s.shader = this.shader;
		s.PAST__ = this.PAST__;
		return s;
	}
	,__class__: prefab.Temporal
	,__properties__: {set_PAST:"set_PAST",get_PAST:"get_PAST"}
});
prefab.TemporalShader = function(parent,contextShared) {
	this.PAST = false;
	hrt.prefab.Shader.call(this,parent,contextShared);
};
$hxClasses["prefab.TemporalShader"] = prefab.TemporalShader;
prefab.TemporalShader.__name__ = "prefab.TemporalShader";
prefab.TemporalShader.getSerializablePropsStatic = function() {
	if(prefab.TemporalShader.serializablePropsFields == null) {
		prefab.TemporalShader.serializablePropsFields = [{ name : "PAST", meta : { }, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : false},{ name : "targetMaterial", meta : { }, hasSetter : false, type : hrt.prefab.PrefabFieldType.PString, defaultValue : null},{ name : "recursiveApply", meta : { }, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : true},{ name : "name", meta : { doc : "\r\n\t\tThe name of the prefab in the tree view\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PString, defaultValue : ""},{ name : "source", meta : { doc : "\r\n\t\tThe associated source file (an image, a 3D model, etc.) if the prefab type needs it.\r\n\t"}, hasSetter : true, type : hrt.prefab.PrefabFieldType.PString, defaultValue : null},{ name : "enabled", meta : { doc : "\r\n\t\tTells if the prefab will create an instance when calling make() or be ignored. Also apply to this prefab children.\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : true},{ name : "editorOnly", meta : { doc : "\r\n\t\tTells if the prefab will create an instance when used in an other prefab or in game. Also apply to this prefab children.\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : false},{ name : "inGameOnly", meta : { doc : "\r\n\t\tTells if the prefab will create an instance when used in editor. Also apply to this prefab children.\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : false},{ name : "locked", meta : { doc : "\r\n\t\tPrevent the prefab from being selected in Hide. Also apply to this prefab children.\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PBool, defaultValue : false},{ name : "props", meta : { doc : "\r\n\t\tA storage for some extra properties\r\n\t"}, hasSetter : false, type : hrt.prefab.PrefabFieldType.PUnknown, defaultValue : null}];
	}
	return prefab.TemporalShader.serializablePropsFields;
};
prefab.TemporalShader.__super__ = hrt.prefab.Shader;
prefab.TemporalShader.prototype = $extend(hrt.prefab.Shader.prototype,{
	PAST: null
	,makeShader: function() {
		return new prefab.Temporal();
	}
	,updateInstance: function(propName) {
		hrt.prefab.Shader.prototype.updateInstance.call(this,propName);
		var sh = js.Boot.__cast(this.shader , prefab.Temporal);
		sh.constModified = true;
		sh.PAST__ = this.PAST;
	}
	,edit: function(ctx) {
		var _gthis = this;
		ctx.properties.add($("\r\n\t\t\t<dl>\r\n\t\t\t\t<div class=\"group\" name=\"Mode\">\r\n\t\t\t\t\t<dt>Past</dt><dd><input type=\"checkbox\" field=\"PAST\"/></dd>\r\n\t\t\t\t</div>\r\n\t\t\t</dl>\r\n\t\t"),this,function(pname) {
			ctx.onChange(_gthis,pname);
		});
	}
	,make: function(sh) {
		if(this.shared == sh) {
			sh = null;
		}
		if(sh != null || !this.shared.isInstance) {
			return this.makeClone(sh);
		}
		if(!this.shouldBeInstanciated()) {
			return this;
		}
		return this.__makeInternal();
	}
	,copyFromDynamic: function(obj) {
		hrt.prefab.Shader.prototype.copyFromDynamic.call(this,obj);
		this.PAST = obj.PAST != null && obj.PAST;
	}
	,copyFromOther: function(obj) {
		hrt.prefab.Shader.prototype.copyFromOther.call(this,obj);
		var obj1 = obj;
		this.PAST = obj1.PAST;
	}
	,copyToDynamic: function(obj) {
		if(obj == null) {
			obj = { };
		}
		obj = hrt.prefab.Shader.prototype.copyToDynamic.call(this,obj);
		if(this.PAST != false) {
			obj.PAST = this.PAST;
		}
		return obj;
	}
	,postCloneInit: function() {
		hrt.prefab.Shader.prototype.postCloneInit.call(this);
	}
	,__class__: prefab.TemporalShader
});
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
prefab.Temporal.SRC = "HXSMD3ByZWZhYi5UZW1wb3JhbAEBBFBBU1QCAgABAAAAAAAA";
prefab.Temporal._MODULE = "prefab.TemporalShader";
prefab.TemporalShader._ = hrt.prefab.Prefab.register("temporalShader",prefab.TemporalShader);
prefab.TemporalShader.serializablePropsFields = null;

//# sourceMappingURL=hide-plugin.js.map